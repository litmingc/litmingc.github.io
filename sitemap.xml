<search>
    
     <entry>
        <title>[Translation]Whoosh 2.7.4 Documentation</title>
        <url>https://litmingc.github.io/post/translation/whoosh/</url>
        <categories>
          <category>Translation</category><category>Python</category>
        </categories>
        <tags>
          <tag>whoosh</tag><tag>文档检索</tag>
        </tags>
        <content type="html"> 英语小白，【原文地址】。store不知道怎么翻译合适，存储？
 Quick start  A quick introduction The Index and Schema objects The IndexWriter object The Searcher object   Designing a schema  About schemas and fields Built-in field types Creating a Schema Modifying the schema after indexing Dynamic fields Advanced schema setup  Field boosts Field types Formats Vectors     How to index documents  Creating an Index object Clearing the index Indexing documents Indexing and storing different values for the same field Finishing adding documents Merging segments Deleting documents Updating documents Incremental indexing Clearing the index   How to search  The Searcher object    Quick start whoosh是一个为文本建立索引并搜索这个索引的方法库和类库。它允许你针对自己的内容开发自定义的搜索引擎。比如，如果你正在建立一个博客写作软件，你就可以使用Whoosh添加搜索方法，让用户搜索博文。
A quick introduction from whoosh.index import create_in from whoosh.fields import * schema = Schema(title=TEXT(stored=True), path=ID(stored=True), content=TEXT) ix = create_in(&amp;#34;indexdir&amp;#34;, schema) writer = ix.writer() writer.add_document(title=u&amp;#34;First document&amp;#34;, path=u&amp;#34;/a&amp;#34;,content=u&amp;#34;This is the first document we&amp;#39;ve added!&amp;#34;) writer.add_document(title=u&amp;#34;Second document&amp;#34;, path=u&amp;#34;/b&amp;#34;,content=u&amp;#34;The second one is even more interesting!&amp;#34;) writer.commit() from whoosh.qparser import QueryParser with ix.searcher() as searcher: query = QueryParser(&amp;#34;content&amp;#34;, ix.schema).parse(&amp;#34;first&amp;#34;) results = searcher.search(query) print(results[0]) 输出：
{&amp;quot;title&amp;quot;: u&amp;quot;First document&amp;quot;, &amp;quot;path&amp;quot;: u&amp;quot;/a&amp;quot;}
The Index and Schema objects 首先，使用whoosh前，你需要有一个索引（index）对象；
其次，使用index前，你必须定义好index的schema(结构模式)。
schema列出了index中的字段（field）。一个字段（field）就是索引中记录的文档的一项信息。field能够被索引(indexed)（可以搜索field）、被存储(stored)（被索引的field的值会和结果一起返回；在标题等字段中，这一点很有用）。
下面的schema示例中有两个字段，“title”和“content”：
from whoosh.fields import Schema, TEXT schema = Schema(title=TEXT, content=TEXT) 创建index时，你只需要创建一个schema。这个schema和index深度绑定。
创建schema对象时，你使用关键字参数来把字段名和字段类型绑定在一起。字段列表以及他们的类型决定了“哪些会被索引，哪些能被检索”。Whoosh自带了一些非常有用的字段类型，并且你也可以轻易的定义自己的类型。
 whoosh.fields.ID
这种类型简单地把整个字段的值索引成一个单元(a single unit，也就是说，它不会把字段的值切分成单独的词语)，同时也可以选择存储这个值。这在诸如文件路径、URL、日期以及分类等字段中很有用。 whoosh.fields.STORED
使用这个类型的字段会被储存为文档，但是不会为它建立索引。这个字段类型不会被索引，也不可搜索。它可以用在一些文档信息上，而你只是想把这些文档信息呈现在搜索结果中。 whoosh.fields.KEYWORD
这个类型是为那些用空格和逗号分隔的关键字设计的，可以被索引、被搜索，也可以选择将其存储。为了节省空间，这个类型的字段的搜索并不允许部分匹配（phrase searching）。 whoosh.fields.TEXT
这是用于正文的字段类型。它为文本建立索引（可选择存储与否）并且储存词语的位置用于片言搜索（phrase searching） whoosh.fields.NUMERIC
用于数字，可以存储整型和浮点数。 whoosh.fields.BOOLEAN
用于布尔值（true，false） whoosh.fields.DATETIME
用于datatime对象。更多信息参见Indexing and parsing dates/times whoosh.fields.NGRAM 和 whoosh.fields.NGRAMWORDS
这个类型把字段的文本以及单个的术语打散，将它们组成N元组(N-grams)。更多信息参见Indexing and searching N-grams  （如果你不需要向字段类型传递参数，那么只要给出类名就可以了。Whoosh会帮你实例化。）
from whoosh.fields import Schema, STORED, ID, KEYWORD, TEXT schema = Schema(title=TEXT(stored=True), content=TEXT, path=ID(stored=True), tags=KEYWORD, icon=STORED) 更多信息参见Designing a schema
一旦你有了schema，你就可以使用create_in方法创建index:
import os.path from whoosh.index import create_in if not os.path.exists(&amp;#34;index&amp;#34;): os.mkdir(&amp;#34;index&amp;#34;) ix = create_in(&amp;#34;index&amp;#34;, schema) （这一步创建了一个包含索引&amp;quot;index&amp;quot;的存储对象。Storage对象是将被储存的index的中间件。通常，存储对象会是FileStorage对象，将index存储为一组文件，存储到某个文件夹中。）
在创建了一个index之后，你可以使用open_dir方法，很方便的打开它：
from whoosh.index import open_dir ix = open_dir(&amp;#34;index&amp;#34;) The IndexWriter object 好的，既然我们已经有的index对象了，那现在就可以添加文档了。index对象的writer()方法会返回一个IndexWriter对象，可以用来将文档添加进index。IndexWriter对象的add_document(**kwargs)方法通过传入的关键字参数，将字段名映射到具体的值。
writer = ix.writer() writer.add_document(title=u&amp;#34;My document&amp;#34;, content=u&amp;#34;This is my document!&amp;#34;, path=u&amp;#34;/a&amp;#34;, tags=u&amp;#34;first short&amp;#34;, icon=u&amp;#34;/icons/star.png&amp;#34;) writer.add_document(title=u&amp;#34;Second try&amp;#34;, content=u&amp;#34;This is the second example.&amp;#34;, path=u&amp;#34;/b&amp;#34;, tags=u&amp;#34;second short&amp;#34;, icon=u&amp;#34;/icons/sheep.png&amp;#34;) writer.add_document(title=u&amp;#34;Third time&amp;#39;s the charm&amp;#34;, content=u&amp;#34;Examples are many.&amp;#34;, path=u&amp;#34;/c&amp;#34;, tags=u&amp;#34;short&amp;#34;, icon=u&amp;#34;/icons/book.png&amp;#34;) writer.commit() 其中，有两点需要注意：
 你不一定要为所有的字段赋值。Whoosh根本不在乎。 建立索引的字段的文本参数必须是以unicode编码的字符串。那些只存储不建立索引的字段（STORED类型）可以传入任何编码的对象。  如果你有一个文本字段，既要建立索引，也要被存储，那么你可以为unicode编码值建立索引，然后再用下面展示的技巧存储一个不同的对象（如果必要的话，但是通常没必要。 又 但是，有时候，这真的很有用）：
writer.add_document(title=u&amp;#34;Title to be indexed&amp;#34;, _stored_title=u&amp;#34;Stored title&amp;#34;) 调用IndexWriter的commit()来提交那些添加到index中的文档：
writer.commit() 更多信息参见How to index documents
一旦文档被提交到index中，那你就可以搜索它们了。
The Searcher object 为了检索index，我们需要一个Searcher对象：
searcher = ix.searcher() 你通常会想要通过with语句打开检索器(Searcher)。这样，当你使用完检索器，它就会自动关闭了（Searcher对象表示很多打开的文件。所以，如果你没有显式地关闭他们，而且系统收集他们的速度也慢的话，你可能会花光文件句柄）。
with ix.searcher() as searcher: pass 等价于：
try: searcher = ix.searcher() pass finally: searcher.close() Searcher对象的search()方法需要一个查询(Query)对象。你可以直接构造query对象，也可以使用query分析器分析query字符串。
比如，下面的查询对象将会匹配在“content”字段中同时包含“apple”和“bear”的文档：
# Construct query objects directly from whoosh.query import * myquery = And([Term(&amp;#34;content&amp;#34;, u&amp;#34;apple&amp;#34;), Term(&amp;#34;content&amp;#34;, &amp;#34;bear&amp;#34;)]) 此外，你也可以使用qparser模块中默认的查询分析器去分析查询字符串。QueryParser构造器的第一个参数是默认的搜索字段，它通常传入“文本主体”所在的字段。第二个可选参数是一个schema，用来让分析器理解如何分析字段：
# Parse a query string from whoosh.qparser import QueryParser parser = QueryParser(&amp;#34;content&amp;#34;, ix.schema) myquery = parser.parse(querystring) 只要你有了Searcher和query对象，你就可以使用Searcher的search()方法来执行查询，获得Results对象：
&amp;gt;&amp;gt;&amp;gt; results = searcher.search(myquery) &amp;gt;&amp;gt;&amp;gt; print(len(results)) 1 &amp;gt;&amp;gt;&amp;gt; print(results[0]) {&amp;#34;title&amp;#34;: &amp;#34;Second try&amp;#34;, &amp;#34;path&amp;#34;: &amp;#34;/b&amp;#34;, &amp;#34;icon&amp;#34;: &amp;#34;/icons/sheep.png&amp;#34;} 默认的QueryParser实现查询语言的方式和Lucene中的非常相似。它允许使用AND或者OR联系语句，使用NOT排除语句，把语句组合成带括号的子句，进行范围、前缀以及通配符查询，并指定不同字段去搜索。默认情况下，它使用AND组合查询子句（所以，默认情况下，你所指定的全部搜索词必须全在文档中，文档才能被匹配）：
&amp;gt;&amp;gt;&amp;gt; print(parser.parse(u&amp;#34;render shade animate&amp;#34;)) And([Term(&amp;#34;content&amp;#34;, &amp;#34;render&amp;#34;), Term(&amp;#34;content&amp;#34;, &amp;#34;shade&amp;#34;), Term(&amp;#34;content&amp;#34;, &amp;#34;animate&amp;#34;)]) &amp;gt;&amp;gt;&amp;gt; print(parser.parse(u&amp;#34;render OR (title:shade keyword:animate)&amp;#34;)) Or([Term(&amp;#34;content&amp;#34;, &amp;#34;render&amp;#34;), And([Term(&amp;#34;title&amp;#34;, &amp;#34;shade&amp;#34;), Term(&amp;#34;keyword&amp;#34;, &amp;#34;animate&amp;#34;)])]) &amp;gt;&amp;gt;&amp;gt; print(parser.parse(u&amp;#34;rend*&amp;#34;)) Prefix(&amp;#34;content&amp;#34;, &amp;#34;rend&amp;#34;) Whoosh还有额外的功能处理检索结果，比如：
 以索引字段的值排序，而不是相关程度 在原文的节选中，高亮搜索字段 基于检索到的前几个文档，扩展搜索选项 分页显示结果（例如，“显示结果 1-20 ，页面1 of 4”）
更多内容参见How to search  Designing a schema About schemas and fields schema指定了文档在索引中的字段。
每一篇文档都可以有多个字段，比如title、content、url、date等等。
某些字段可以被索引。某些字段可以和文档一起存储，用于在检索的结果中显示这些字段的值。某些字段既可以被索引，也可以被存储。
schema是文档中可能出现的字段的集合，每一篇文档都可能仅仅使用它的子集。
比如，一个用于索引邮件的schame可能的字段有from_addr、 to_addr、subject、body以及attachments，attachments字段可能以列表形式列出了邮件的附件名。对于没有附件的邮件，你就可以忽略这个字段。
Built-in field types Whoosh提供了一些实用的预设字段类型：
 whoosh.fields.TEXT
这个类型用于文本主体。它为文本建立索引，并且记录词语的位置以便短语检索；亦可增选存储起来。
TEXT字段默认使用StandarAnalyzer进行分词。要指定不同的分词器，你可以为字段的构造器使用analyzer参数，比如TEXT(analyzer=analysis.StemmingAnalyzer())。详情见See About analyzers
TEXT字段默认储存词语的位置，用于短语检索。如果你不需要这个功能，你可以关闭它以节省存储空间。使用TEXT(phrase=False)关闭此功能。 TEXT字段默认不存储字段的值。通常，你不会希望在索引中储存文档的正文。因为一般情况下，你可以从检索结果中直接读取或者链接到文档本身，所以无需在索引中存储文本。但是，在某些情况下，储存字段的值会是实用的，比如How to create highlighted search result excerpts。使用TEXT(stored=True)将文本存储到索引中。 whoosh.fields.KEYWORD
这个类型是设计给以空格、逗号分隔的关键词的。此类型可索引，也可存储展示。为了节省空间，它不支持短语检索。
在构造器中使用stored=True存储展示字段的值；使用lowercase=True将在索引建立前自动小写关键字。
默认情况下，它认为关键字是以空格为分割符的，可设置commas=True使用逗号替代空格成为分隔符（注意，此时即允许关键字中含有空格）。
如果你的使用者将使用关键字字段进行检索，请设置scorable=True。 whoosh.fields.ID
ID类型简单地将字段的整个值当作一个单元（不会将字段分隔成一个一个词语）进行索引（and optionally stores）。这个类型不会存储词频，因此它完成得很快，但对于文档相关度的计算就没啥用了。
ID类型一般用于URL、文件路径、日期、分类等字段，这些字段通常需要当成整体来对待，并且一个文档只有一个值。
默认情况下，ID类型也不被存储展示。设置ID(stored=true)，使指定的字段可以被存储，用于在检索结果中展示。比如，你可以存储URL的值，以便在检索结果中提供文档的链接。 whoosh.fields.STORED
这个类型用于存储文档，但是不能建立索引也不能检索，主要用在你希望在检索结果中展示，却不必检索得到的文档信息上。 whoosh.fields.NUMERIC
用紧凑、可排序得形式存储int、long、浮点数。 whoosh.fields.DATETIME
用紧凑、可排序得形式存储日期对象。 whoosh.fields.BOOLEAN
用于索引布尔值。用户可以使用yes no true false 1 0 t f检索到这个类型的字段。 whoosh.fields.NGRAM
TBD.  Creating a Schema 举个栗子：
from whoosh.fields import Schema, TEXT, KEYWORD, ID, STORED from whoosh.analysis import StemmingAnalyzer schema = Schema(from_addr=ID(stored=True), to_addr=ID(stored=True), subject=TEXT(stored=True), body=TEXT(analyzer=StemmingAnalyzer()), tags=KEYWORD) 如果不需要为原生的字段类型构造器提供参数，可以省略()（比如，用fieldname=TEXT代替fieldname=TEXT()）。whoosh会帮你实例化。
此外，你还可以使用SchemaClass基础类来声明一个Schema：
from whoosh.fields import SchemaClass, TEXT, KEYWORD, ID, STORED class MySchema(SchemaClass): path = ID(stored=True) title = TEXT(stored=True) content = TEXT tags = KEYWORD 你可以将上述声明类当参数传给方法create_in()或者create_index()，而不必使用Schema实例。
Modifying the schema after indexing 在已经建立索引之后，你可以使用add_field()和remove_field()增减字段。这两个方法是writer对象的成员方法：
writer = ix.writer() writer.add_field(&amp;#34;fieldname&amp;#34;, fields.TEXT(stored=True)) writer.remove_field(&amp;#34;content&amp;#34;) writer.commit() （如果增减字段和添加文档使用的是同一个writer，你必须确保在添加文档前调用add_field()以及remove_field()。）
在index对象中，这些方法使用起来也很方便：
ix.add_field(&amp;#34;fieldname&amp;#34;, fields.KEYWORD) 但是，当你这么用的时候，index对象实际上是创建了writer，并调用了对应的函数再提交（commit）的。所以，若是你想增减多个字段，使用writer会更有效率。
在filedb后台，移除一个字段仅仅对schema做了修改，index并不会变小，index有关那个字段的数据仍然存在，除非你commit的时候使用了optimize（优化）。优化可以重构索引，移除相应字段的引用。示例如下：
writer = ix.writer() writer.add_field(&amp;#34;uuid&amp;#34;, fields.ID(stored=True)) writer.remove_field(&amp;#34;path&amp;#34;) writer.commit(optimize=True) 因为数据是和字段名一起存储在磁盘上的，所以不要在移除字段且不设置optimize的情况下，添加同名的字段：
writer = ix.writer() writer.delete_field(&amp;#34;path&amp;#34;) # Don&amp;#39;t do this!!! writer.add_field(&amp;#34;path&amp;#34;, fields.KEYWORD) （未来，whoosh也许会自动避免这个错误。）
Dynamic fields 动态字段就是把类型与一组字段联系起来，这些字段能够被给定的“通配符”匹配（通配符（glob）指一种命名模板，包含*、？以及[abc]通配符）。
你可以使用带glob关键字的add()方法添加动态字段（设置glob=True：
schema = fields.Schema(...) # Any name ending in &amp;#34;_d&amp;#34; will be treated as a stored # DATETIME field schema.add(&amp;#34;*_d&amp;#34;, fields.DATETIME(stored=True), glob=True) 和添加普通的字段一样，你可以使用IndexWriter.add_field()添加动态字段。但是，需要设置glob=True：
writer = ix.writer() writer.add_field(&amp;#34;*_d&amp;#34;, fields.DATETIME(stored=True), glob=True) writer.commit() 移除动态字段时，使用IndexWriter.remove_field()，并给出“统配符字段名”：
writer = ix.writer() writer.remove_field(&amp;#34;*_d&amp;#34;) writer.commit() 下面是一个示例，展示了如何允许文档包含任何以_id结尾的字段名，并指定其为ID类型：
schema = fields.Schema(path=fields.ID) schema.add(&amp;#34;*_id&amp;#34;, fields.ID, glob=True) ix = index.create_in(&amp;#34;myindex&amp;#34;, schema) w = ix.writer() w.add_document(path=u&amp;#34;/a&amp;#34;, test_id=u&amp;#34;alfa&amp;#34;) w.add_document(path=u&amp;#34;/b&amp;#34;, class_id=u&amp;#34;MyClass&amp;#34;) # ... w.commit() qp = qparser.QueryParser(&amp;#34;path&amp;#34;, schema=schema) q = qp.parse(u&amp;#34;test_id:alfa&amp;#34;) with ix.searcher() as s: results = s.search(q) Advanced schema setup Field boosts 你可以为字段指定field boost（字段增强器），它可以倍增某个字段中出现的任意term的检索价值。比如下面的示例中，在计算文档与检索条件的相关性的时候，title字段中出现的相关词句（term），分数会是body中的两倍：
schema = Schema(title=TEXT(field_boost=2.0), body=TEXT) Field types 前文列出的预设类型都是fields.FieldType的子类。FieldType是一个非常简单的类，它的属性中包含了定义字段行为的信息：
   Attribute Type Description     format fields.Format Defines what kind of information a field records about each term, and how the information is stored on disk.   vector fields.Format Optional: if defined, the format in which to store per-document forward-index information for this field.   scorable bool If True, the length of (number of terms in) the field in each document is stored in the index. Slightly misnamed, since field lengths are not required for all scoring. However, field lengths are required to get proper results from BM25F.   stored bool If True, the value of this field is stored in the index.   unique bool If True, the value of this field may be used to replace documents with the same value when the user calls document_update() on an IndexWriter.    大多数类型的构造器都有一些参数让你能够自定义表中的内容。比如：
 FieldType.stored TEXT()构造器就有analyzer关键字参数，这个参数的值会传给form对象。  Formats format对象定义了一个字段所记录的每一个term的信息，以及这些信息是如何存储在磁盘上的。
比如，Existence存储posting：
| Doc | | | &amp;mdash; | &amp;mdash; | | 10 | | | 20 | | | 30 | | 而，Positions存储posting：
| Doc | Positions | | &amp;mdash; | &amp;mdash; | | 10 | [1,5,23] | | 20 | [45] | | 30 | [7,12] |
索引代码将字段的unicode字符串发给字段的Format对象。Format对象调用它的解释器（analyzer）将字符串切分成一些标记，再为每一个标记编码。
Wshoosh会忽略下表中的预设format：
| 类名 | 描述 | | &amp;mdash; | &amp;mdash; | | Stored | A “null” format for fields that are stored but not indexed. | | Existence | Records only whether a term is in a document or not, i.e. it does not store term frequency. Useful for identifier fields (e.g. path or id) and “tag”-type fields, where the frequency is expected to always be 0 or 1. | | Frequency | Stores the number of times each term appears in each document. | | Positions | Stores the number of times each term appears in each document, and at what positions. |
此外，还有一些不常用的format，它们主要是方便一些强者的使用：
| 类名 | 描述 | | &amp;mdash; | &amp;mdash; | | DocBoosts|Like Existence, but also stores per-document boosts | | Characters|Like Positions, but also stores the start and end character indices of each term | | PositionBoosts|Like Positions, but also stores per-position boosts | | CharacterBoosts|Like Positions, but also stores the start and end character indices of each term and per-position boosts |
Vectors 主要的index是一个反向索引。它将term映射到其所在的文档。它有时也有助于储存前向索引（亦称term vector），即把文档映射到文档中的term上。
比如，你可以想象一个字段的反向索引：
| Term | Postings | | &amp;mdash; | &amp;mdash; | | apple | [(doc=1, freq=2), (doc=2, freq=5), (doc=3, freq=1)] | | bear | [(doc=2, freq=7)] |
相应的前向索引，或者说term vector，应该是这样的：
| Doc | Postings | | &amp;mdash; | &amp;mdash; | | 1 | [(text=apple, freq=2)] | | 2 | [(text=apple, freq=5), (text=&#39;bear&amp;rsquo;, freq=7)] | | 3 | [(text=apple, freq=1)] |
如果你为一个Format对象设置了FieldType.vector，那么索引代码就会使用这个Format对象来存储每一个文档中的那些term。目前，Whoosh默认不使用任何term vector，但是对于想要实现自己的字段类型的大神们而言，这个功能是可用的。
How to index documents Creating an Index object 使用index.create_in在指定目录中创建一个index：
import os, os.path from whoosh import index if not os.path.exists(&amp;#34;indexdir&amp;#34;): os.mkdir(&amp;#34;indexdir&amp;#34;) ix = index.create_in(&amp;#34;indexdir&amp;#34;, schema) 使用index.open_dir打开指定文件夹存在的index：
import whoosh.index as index ix = index.open_dir(&amp;#34;indexdir&amp;#34;) 这儿还有些快捷函数(convenience functions)：
from whoosh.filedb.filestore import FileStorage storage = FileStorage(&amp;#34;indexdir&amp;#34;) # Create an index ix = storage.create_index(schema) # Open an existing index storage.open_index() 你创建index所用的schame是和index深度捆绑且一起存储的。
你可以在同一个文件中创建多个index，但是需要使用indexname关键字指定：
# Using the convenience functions ix = index.create_in(&amp;#34;indexdir&amp;#34;, schema=schema, indexname=&amp;#34;usages&amp;#34;) ix = index.open_dir(&amp;#34;indexdir&amp;#34;, indexname=&amp;#34;usages&amp;#34;) # Using the Storage object ix = storage.create_index(schema, indexname=&amp;#34;usages&amp;#34;) ix = storage.open_index(indexname=&amp;#34;usages&amp;#34;) Clearing the index 调用index.create_in将会清除目录中已存在的index中的内容。
使用index.exists_in可以判断目录中的是否包含有效index：
exists = index.exists_in(&amp;#34;indexdir&amp;#34;) usages_exists = index.exists_in(&amp;#34;indexdir&amp;#34;, indexname=&amp;#34;usages&amp;#34;) （此外，也可以直接删除index的相关文件。如果目录中仅有一个index，你可以使用shutil.rmtree移除文件夹并重新创建它。）
Indexing documents 一旦创建好Index对象，你就可以使用IndexWriter向index中添加文档了。获取IndexWriter对象的最简单的方式就是调用index.writer()：
ix = index.open_dir(&amp;#34;index&amp;#34;) writer = ix.writer() 创建了writer的时候会锁定index。因此，同一时间，一个线程（或进程）只能存在一个writer：
Note
你需要有意识到，因为打开一个writer的时候会把index锁定，所以在多线程（多进程）的编程环境中，打开writer时可能会抛出异常（whoosh.store.LockError，如果已经有一个writer被打开了）。Whoosh包含了一组实现样例（whoosh.writing.AsyncWriter和whoosh.writing.BufferedWriter），它们可以绕开写入锁。  Note
即便writer已打开且处于commit中，index仍然是可以被读取的。已存在的reader不受影响，新的reader也能正常地打开最新的index。但是，commit完成之后，已存在的reader只能获取先前的index（也就是说，它们不会自动更新最新的提交内容）。  IndexWriter的add_document(**kwargs)方法以参数的形式将字段名映射到值：
writer = ix.writer() writer.add_document(title=u&amp;#34;My document&amp;#34;, content=u&amp;#34;This is my document!&amp;#34;, path=u&amp;#34;/a&amp;#34;, tags=u&amp;#34;first short&amp;#34;, icon=u&amp;#34;/icons/star.png&amp;#34;) writer.add_document(title=u&amp;#34;Second try&amp;#34;, content=u&amp;#34;This is the second example.&amp;#34;, path=u&amp;#34;/b&amp;#34;, tags=u&amp;#34;second short&amp;#34;, icon=u&amp;#34;/icons/sheep.png&amp;#34;) writer.add_document(title=u&amp;#34;Third time&amp;#39;s the charm&amp;#34;, content=u&amp;#34;Examples are many.&amp;#34;, path=u&amp;#34;/c&amp;#34;, tags=u&amp;#34;short&amp;#34;, icon=u&amp;#34;/icons/book.png&amp;#34;) writer.commit() 建立索引的字段必须赋予unicode编码的值；存储但不索引的字段可以使用任意编码。
Whoosh允许使用同样的值添加文档，这可能会很有用，也有可能令人厌烦：
writer.add_document(path=u&amp;#34;/a&amp;#34;, title=u&amp;#34;A&amp;#34;, content=u&amp;#34;Hello there&amp;#34;) writer.add_document(path=u&amp;#34;/a&amp;#34;, title=u&amp;#34;A&amp;#34;, content=u&amp;#34;Deja vu!&amp;#34;) 这个例子添加了具有相同path和title的两个文档。
下文的“updating documents”会有关于update_document方法的介绍，它使用“unique”参数来替换旧文档，而不是新增文档。
Indexing and storing different values for the same field 如果你有一个字段既能索引也能存储，那么，必要情况下，你可以索引一个unuicode编码的值并存储一个不同的值（通常这是不必要的，但有时这真的很有用 似曾相识的话 ）。使用一个特殊的关键字参数_stored_&amp;lt;fieldname&amp;gt;可以实现这个功能。一般的参数值会被分析并建立索引，而带有“stored”的参数的值会被展示在检索结果中：
writer.add_document(title=u&amp;#34;Title to be indexed&amp;#34;, _stored_title=u&amp;#34;Stored title&amp;#34;) Finishing adding documents IndexWriter就像数据库事务一样。你进行一连串的操作，然后一次性提交它们。
调用commit()保存添加到index中的文档：
writer.commit() 一旦你的文档在index中，你就可以检索它们了。
如果想要关闭writer而不提交，使用cancel()代替commit()：
writer.cancel() 始终要记住，如果你要打开一个writer（或者已经打开过writer并且尚未关闭），那么就应当不会有其它线程或者进程会获取相同index的writer或修改该index。一个writer可能会占用多个打开的文件，所以你也应该记住在不需要writer的时候要调用commit()或者cancel()。
Merging segments Whoosh的filedb索引实际上是一个容器，用于一个或多个称为段的子索引。当您将文档添加到索引中时，并不是将新文档整合进现有文档(这操作的代价可能非常昂贵，因为它涉及到在磁盘上使用所有已索引的term)，而是在现有段的后面创建一个新段。然后，当你检索索引时，Whoosh将分别搜索两个段并合并结果，使这些段看起来是一个统一的索引。(这个巧妙的设计是抄袭Lucene的。)
所以，相交于每次添加文档都重写整个index，拥有几个搜索段将会使搜索更加高效。但是，在检索某些内容时，多段同时检索可能会变慢，并且段越多检索越慢。因此，whoosh采用了一种算法，在你调用commit()的时候，算法会检查较小的段，将提交的内容合并到小的段中，使得段的个数少些、段的大小大些。
提交时，使用merge=False避免whoosh自动整合段：
writer.commit(merge=False) 而，要合并所有段，将index优化为单一的段，请使用optimize=True：
writer.commit(optimize=True) 由于优化会重写index中的所有信息，所以在大型index中会很慢。通常，最好还是依靠whoosh的算法，而不是一直使用优化功能。
（Index对象也有一个optmize()方法可以用来优化index（合并为单一段）。它仅仅创建一个writer并调用commit(optimize=True)。）
如果想要更好地控制合并段，你可以制定自己的合并策略，并且在commit()中指定它。参见whoosh.writing模块中NO_MERGE、MERGE_SMALL以及OPTIMIZE的实现。
Deleting documents 你可以使用IndexWriter对象提供的如下方法删除文档，然后调用commit()提交修改。
 delete_document(docnum)
通过内部的文档编号删除文档，低级方法。 is_deleted(docnum)
如果指定编号的文档已经被删除，返回True，低级方法？基础方法？基层方法？low-level。 delete_by_term(fieldname, termtext)
删除指定字段名中包含指定内容的文档。通常用于ID或KEYWORD字段。 delete_by_query(query)
删除所有与query匹配的文档  # Delete document by its path -- this field must be indexed ix.delete_by_term(&amp;#39;path&amp;#39;, u&amp;#39;/a/b/c&amp;#39;) # Save the deletion to disk ix.commit() 在filedb后台，“删除”文档仅仅是把文档的编号添加到已删文档列表中，这个列表仍然存储在index中。当检索index时，whoosh知道检索结果中不需要返回已经删除的文档。然而，文档的内容依旧储存在index中（，只是关于文档的一些统计信息不再更新），直到合并包含已删文档的段。（因为，立即从index中删除文档会涉及到重写磁盘上的整个index，这会非常低效。）
Updating documents 如果你想替换文档，可以删除旧文档，再添加新的文档。或者，使用IndexWriter.update_document进行这一步操作。
使用update_document，你必须在schema中标记至少一个字段为“unique”。whoosh会使用“unique”字段的内容去寻找需要删除的文档：
from whoosh.fields import Schema, ID, TEXT schema = Schema(path = ID(unique=True), content=TEXT) ix = index.create_in(&amp;#34;index&amp;#34;) writer = ix.writer() writer.add_document(path=u&amp;#34;/a&amp;#34;, content=u&amp;#34;The first document&amp;#34;) writer.add_document(path=u&amp;#34;/b&amp;#34;, content=u&amp;#34;The second document&amp;#34;) writer.commit() writer = ix.writer() # Because &amp;#34;path&amp;#34; is marked as unique, calling update_document with path=&amp;#34;/a&amp;#34; # will delete any existing documents where the &amp;#34;path&amp;#34; field contains &amp;#34;/a&amp;#34;. writer.update_document(path=u&amp;#34;/a&amp;#34;, content=&amp;#34;Replacement for the first document&amp;#34;) writer.commit() “unique”字段必须是被索引的。
如果需要更新的文档不存在，那么update_document的作用将和add_document相似。
“unique”和undate_document仅仅是删除和添加的一个快捷方式。whoosh本身没有unique标志符的概念，当你使用add_document时并不能保证唯一性。
Incremental indexing 索引一个文档集合的编程方式通常有两种：
一种是从头索引所有文档；另一种是只更新改变的文档 (leaving aside web applications where you need to add/update documents according to user actions)。
第一种方式很简单，示例如下：
import os.path from whoosh import index from whoosh.fields import Schema, ID, TEXT def clean_index(dirname): # Always create the index from scratch ix = index.create_in(dirname, schema=get_schema()) writer = ix.writer() # Assume we have a function that gathers the filenames of the # documents to be indexed for path in my_docs(): add_doc(writer, path) writer.commit() def get_schema() return Schema(path=ID(unique=True, stored=True), content=TEXT) def add_doc(writer, path): fileobj = open(path, &amp;#34;rb&amp;#34;) content = fileobj.read() fileobj.close() writer.add_document(path=path, content=content) 对于少量的文档，这种方式是足够迅速的。但是，面对大量文档时，你就不想使用这种方式了。
首先，我们需要记录每个文档的最近修改时间，以便在它更改时可以检查到它。简单起见，如下的示例中，我们仅使用mtime：
def get_schema() return Schema(path=ID(unique=True, stored=True), time=STORED, content=TEXT) def add_doc(writer, path): fileobj = open(path, &amp;#34;rb&amp;#34;) content = fileobj.read() fileobj.close() modtime = os.path.getmtime(path) writer.add_document(path=path, content=content, time=modtime) 现在，我们修改之前的脚本，使其既可以选择从头建立索引，也可以增量建立索引：
def index_my_docs(dirname, clean=False): if clean: clean_index(dirname) else: incremental_index(dirname) def incremental_index(dirname) ix = index.open_dir(dirname) # The set of all paths in the index indexed_paths = set() # The set of all paths we need to re-index to_index = set() with ix.searcher() as searcher: writer = ix.writer() # Loop over the stored fields in the index for fields in searcher.all_stored_fields(): indexed_path = fields[&amp;#39;path&amp;#39;] indexed_paths.add(indexed_path) if not os.path.exists(indexed_path): # This file was deleted since it was indexed writer.delete_by_term(&amp;#39;path&amp;#39;, indexed_path) else: # Check if this file was changed since it # was indexed indexed_time = fields[&amp;#39;time&amp;#39;] mtime = os.path.getmtime(indexed_path) if mtime &amp;gt; indexed_time: # The file has changed, delete it and add it to the list of # files to reindex writer.delete_by_term(&amp;#39;path&amp;#39;, indexed_path) to_index.add(indexed_path) # Loop over the files in the filesystem # Assume we have a function that gathers the filenames of the # documents to be indexed for path in my_docs(): if path in to_index or path not in indexed_paths: # This is either a file that&amp;#39;s changed, or a new file # that wasn&amp;#39;t indexed before. So index it! add_doc(writer, path) writer.commit() incremental_index方法中：
 遍历最近索引的文档路径：  如果文件不存在，则删除index中的相关文档形式。 如果文件存在，但是修改过了，则把它添加到重写列表中。 如果文件存在，无论有没有修改，把它添加到所有的索引路径中。   遍历磁盘上的所有文件路径：  如果文件路径不在索引中，这个文件就是新文件，需要添加到index中。 If a path is not in the set of all indexed paths, the file is new and we need to index it. 如果文件路径在重写列表中，就需要索引它。 If a path is in the set of paths to re-index, we need to index it. 或者，跳过这一步。 Otherwise, we can skip indexing the file.    Clearing the index 某些情况下，你需要在不破坏已经存在的reader的前提下，重头建立index：
from whoosh import writing with myindex.writer() as mywriter: # You can optionally add documents to the writer here # e.g. mywriter.add_document(...) # Using mergetype=CLEAR clears all existing segments so the index will # only have any documents you&amp;#39;ve added to this writer mywriter.mergetype = writing.CLEAR 或者，不使用writer上下文管理器，直接调用commit()，像这样：
mywriter = myindex.writer() # ... mywriter.commit(mergetype=writing.CLEAR) Note
如果你不需要担心已经存在的reader，更高效的方式是直接删除index目录中的内容，然后重启。  How to search 若你已经建立了索引，并且添加了文档，那么就可以检索这些文档了。
The Searcher object 通过调用Index对象的searcher()获得whoosh.searching.Searcher对象：
searcher = myindex.searcher() </content>
    </entry>
    
     <entry>
        <title>[Tips]颜色mark</title>
        <url>https://litmingc.github.io/post/tips/tips%E9%A2%9C%E8%89%B2mark/</url>
        <categories>
          
        </categories>
        <tags>
          
        </tags>
        <content type="html"> 也不知道哪儿来的颜色名ヾ(。￣□￣)ﾂ゜゜゜
  玄青 #3d3b50   雪青 #b0a4e2   鸦青 #434a52   鸭卵青 #dfeee7   牙色 #efdeb0     枣红 #883040   章丹 #ee652e   正灰 #94a1a9   中棕灰 #a9987e   纸棕 #bba590   织锦灰 #758a8f   紫藤灰 #847f95   紫水晶 #c2a6cc  </content>
    </entry>
    
     <entry>
        <title>[Tips]算法小抄</title>
        <url>https://litmingc.github.io/post/tips/tips%E7%AE%97%E6%B3%95%E5%B0%8F%E6%8A%84/</url>
        <categories>
          
        </categories>
        <tags>
          
        </tags>
        <content type="html"> 说在前头，打小抄可不是什么可耻的事儿！
欧几里得算法证明（最大公约数）1  \(a\) 整除 \(b\) 表示\(b\%a\)为\(0\)； \(a\) 除以 \(b\) 表示 \(b/a\)；我总把除和除以搞混。 \(gcd(a,b)\)表示\(a\)，\(b\)的最大公约数。  问题描述  求\(a\)，\(b\)的最大公约数， 这么简单有啥好描述的啊  证明：
设\(a\)，\(b\) (\(a&amp;gt;b\))的最大公约数为\(c\)。
\(\because\)存在\(q,r,k_1,k_2\) ，使得\(\left\{ \begin{aligned}a=&amp;amp;b*q&#43;r \\ a=&amp;amp;c*k_1 \\ b=&amp;amp;c*k_2 \end{aligned}\right.\) ，
\(\therefore r=a-bq=ck_1-ck_2q=c(k_1-k_2q)\),
又\(\because b=ck_2\)
\(\therefore\)若\(k_2\)与\((k_1-k_2*q)\)互质，则\(r\)和\(b\)的最大公约数也是\(c\)。
下面证明，\(k_2\)与\((k_1-k_2*q)\)互质：
假设\(k_2\)与\((k_1-k_2*q)\)不互质，即有大于1的公约数\(m\)，
则存在\(x\)、\(y\)，使得\(\left\{\begin{aligned}k_2=&amp;amp;xm \\ (k_1-k_2*q)=&amp;amp;ym\end{aligned}\right.\)，
代入\(a\)、\(b\)，得\(\left\{\begin{aligned} a=&amp;amp;b*q&#43;r=xmc*q&#43;ymc=mc(x*q&#43;y)\\ b=&amp;amp;xmc \end{aligned}\right.\)， \(a\)、\(b\)最大公约数为\(mc\),矛盾。
所以，\(k_2\)与\((k_1-k_2*q)\)互质，\(c\)为\(b\)、\(r\)的最大公约数。 即，\(gcd(a,b)=gcd(b,r)=gcd(b,a\%b)=c\)
从上述证明中不难发现a、b、r（\(a\%b\)）有共同的最大公约数，所以不断取其中最小的两个数相除得到更小的一组数，直到这组数中一个数本身就是最大公约数，算法结束。
约瑟夫环 原问题的描述令人悲伤，这里还是借用leetcode的问题描述吧。
问题描述
0,1,,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。  例子  例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。  解析过程： 定义函数\(f(n,m)=x\)：现有\(n\)个数，从下标 \(0\) 开始，依次删去第\(m\)个数，最后留下的数字下标为 \(x\)。（下标与数已经一一对应）
易得：
1. \(f(1,m)\)：只有一个数字时，最后剩下的就是下标\(0\)。
2. \(f(2,m)\)：删去第\(m\)个，也就是第\(m\%2\)个，其下标为\((m-1)\%2\)。此外，仅剩一个数字，它的下标为\(m\%2\)（第\(m&#43;1\)个数）。
3. \(f(3,m)\)：删去第\(m\%3\)个数，剩下两个数… …
从描述过程中，很容易可以感受到：\(n\)个数的问题，在执行了一次的删除之后，可以转化为\(n&#43;1\)个数的问题。
唯一的障碍就是，下标的变化。
如，3.中删去第\(m\%3\)个数后，下一次删除的起点是它的后一个数。从这个数开始，下标依次为\(m\%3\)，\((m&#43;1)\%3\)，\((m&#43;2)\%3\)… ；而，2.中的下标依次是\(0\%2\)，\(1\%2\)，\(2\%2\)…
3.到2.的过程中，下标的变化如下，可以看作全员向前移动\(m\)个位置：
\[ \left \{ \begin{aligned} &amp;amp; (m&#43;0)\%3 &amp;amp; \rightarrow &amp;amp; 0\%2 \\ &amp;amp; (m&#43;1)\%3 &amp;amp; \rightarrow &amp;amp; 1\%2 \\ &amp;amp; \mathellipsis &amp;amp; \rightarrow &amp;amp; \mathellipsis \end{aligned} \right . \]
亦作
\[ \left \{ \begin{aligned} &amp;amp; (m&#43;0)\%3 &amp;amp; = &amp;amp; (0\%2&#43;m)\%3 \\ &amp;amp; (m&#43;1)\%3 &amp;amp; = &amp;amp; (1\%2&#43;m)\%3 \\ &amp;amp; \mathellipsis &amp;amp; = &amp;amp; \mathellipsis \end{aligned} \right . \]
换句话说，\(f(n,m) \rightarrow f(n-1,m)\)的过程可以看作，n个数全部向前移动\(m\)个位置，再切掉第\(n\)个数。\(f(n,m) \leftarrow f(n-1,m)\)的过程可以看作，尾巴上先插一个\(n\)，然后\(n\)个数全部向后移动\(m\)个位置。
删除的过程是不断地进行\(f(n,m) \rightarrow f(n-1,m)\)，倒过来想，若已知最后留下的数（代号A），那么只要不断执行\(f(n,m) \leftarrow f(n-1,m)\)，便可以还原这个数A在任何时候的位置了。
1. \(f(1,m)=0\)；
2. \(f(2,m)=(f(1,m)&#43;m)\%2\)；
3. \(f(3,m)=(f(2,m)&#43;m)\%3\)；
4. \(\dotso\)
不断递推，直到目标\(n\)。
写得乱糟糟，还不如原文一个图来的清楚，【传送门1】2【传送门2】3
 https://blog.csdn.net/weixin_43406046/article/details/84197255?depth_1-utm_source=distribute.pc_relevant.none-task&amp;amp;utm_source=distribute.pc_relevant.none-task “欧几里德算法 CSDN”↩︎
 https://lele16.me/posts/leetcode%E9%9D%A2%E8%AF%95%E9%A2%9862.-%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0%E5%AD%97-%E9%9A%8F%E7%AC%94/↩︎
 https://blog.csdn.net/u011500062/article/details/72855826↩︎
   </content>
    </entry>
    
     <entry>
        <title>[rpi]树莓派使用v2ray</title>
        <url>https://litmingc.github.io/post/linux/%E6%A0%91%E8%8E%93%E6%B4%BE%E4%BD%BF%E7%94%A8v2ray/</url>
        <categories>
          <category>学习笔记</category><category>Linux</category>
        </categories>
        <tags>
          <tag>RaspberryPi</tag><tag>v2ray</tag>
        </tags>
        <content type="html"> 摘录自链接
安装v2ray   GitHub下载相应版本【https://github.com/v2ray/v2ray-core/releases】
树莓派4下载linux-arm.zip，树莓派的官方系统目前(2020.03.12)还是32位。
  下载安装脚本
wget https://install.direct/go.sh  执行安装脚本
sudo bash go.sh --local ./v2ray-linux-arm.zip  配置v2ray
编辑/etc/v2ray/config.json文件进行配置
  v2ray的使用
service命令
service v2ray start //启动v2rayservice v2ray status //查看v2ray状态service v2ray stop //停止v2ray  使用代理   安装proxychains
sudo apt install proxychains  配置proxychains
sudo vim /etc/proxychains.conf在proxychains.conf文件末尾修改你的socks5服务地址，可以把sock4删除
[ProxyList]socks5 127.0.0.1 1080此处的配置与v2ray中的配置对应，即port字段：
&amp;quot;inbounds&amp;quot;: [{&amp;quot;tag&amp;quot;: &amp;quot;proxy&amp;quot;,&amp;quot;port&amp;quot;: 1080,&amp;quot;listen&amp;quot;: &amp;quot;0.0.0.0&amp;quot;,&amp;quot;protocol&amp;quot;: &amp;quot;socks&amp;quot;,# ...},]  使用
在命令前加上proxychains( 此方法只能代理TCP链接，我只要TCP就够了 )
proxychains curl https://www.google.com  </content>
    </entry>
    
     <entry>
        <title>[linux]目录的含义与相关操作</title>
        <url>https://litmingc.github.io/post/linux/%E6%96%87%E4%BB%B6%E5%A4%B9%E7%9A%84%E7%BB%84%E7%BB%87/</url>
        <categories>
          <category>学习笔记</category><category>Linux</category>
        </categories>
        <tags>
          <tag>目录</tag><tag>文件类型</tag>
        </tags>
        <content type="html"> 目录的一般含义 摘录自【链接】
   一级目录 含义     /bin/ 系统命令，普通用户、root都可以执行。   /boot/ 系统启动目录，如：内核文件、引导程序等。   /dev/ 设备文件   /etc/ 配置文件。默认安装方式下的服务配置文件，如：用户信息、启动脚本、常用服务的配置文件等。   /home/ 存放普通用户的主目录   /lib/ 系统调用的函数库   lost&#43;found 系统意外崩溃或意外关机时的恢复目录，不同分区可能都有此目录   /media/ 挂载目录，建议光盘等媒体设备   /mnt/ 挂载目录，挂载额外设备   /misc/ 挂载目录，建议挂载NFS服务的共享目录。（有的系统无此目录，挂载目录的类别不是必须的）   /opt/ 第三方软件安装目录。   /proc/ 虚拟文件系统。保存系统内核进程、外部设备、网络状态等。&amp;lt;br &amp;gt;数据在内存中。因此，在此文件夹中写入数据会使得可用内存越来越小，其它存储在内存中的文件夹同理。   /root/ root的主目录   /run/ 系统启动后的一些运行数据，临时的文件系统，数据不在硬盘中。   /sbin/ 与系统环境设置相关的命令，只有root可以使用这些命令进行环境设置，普通用户可以查看部分命令   /usr/ Unix Software Resource，系统软件资源。   /srv/ 部分系统服务启动后的数据目录   /sys/ 虚拟文件系统，多为内核相关。   /tmp/ 临时目录，所有用户都可以访问和写入。   /var/ 储存动态数据，如：缓存、日志等。    /usr/目录  /usr/bin: 与系统启动无关的系统命令。普通用户和root用户可执行。 /usr/sbin: 存放根文件系统不必要的系统管理命令，如多数服务程序。只有root用户可以使用。 /usr/lib: 应用程序调用的程序库。 /usr/local: 手工安装的软件保存位置。一般建议源码包软件安装在这个位置。 /usr/share: 应用程序的资源文件保存位置，如帮助文档、说明文档和字体目录. /usr/src: 源码包保存位置，手工下载的源码包和内核源码包都可以保存到这里。 /usr/include: C/C&#43;&#43;等编程语言的放置目录。  /var/目录  /var/lib: 程序运行中需要调用或改变的数据保存位置。如,MySQL的数据库保存在/var/lib/mysql/目录中。 /var/log: 登陆文件放置的目录，其中所包含比较重要的文件如/var/log/messages, /var/log/wtmp。 /var/run/: 一些服务和程序运行后，其PID保存位置。 /var/www/: 系统的包工具（yum，apt）安装的Apache等程序的网页主目录。 /var/tmp: 一些应用程序在安装或执行时，需要在重启后使用的某些文件，此目录能将该类文件暂时存放起来，完成后再行删除。  部分软件的目录说明 python 摘录自【链接】，如下：
 python的可执行文件的目录一般在 /usr/bin下，通过apt-get安装的应用一般会在这个目录
自行安装的一般在/usr/local/bin下
python3.5的自带库目录在
/usr/lib/python3/dist-packages
/usr/lib/python3.5/
python2.7的自带库目录在
/usr/lib/python2.6/dist-packages
/usr/lib/python2.7/
通过pip安装的模块目录在
~/.local/lib/python3.5/site-packages
~/.local/lib/python2.7/site-packages
或者
/usr/local/lib/python2.7/dist-packages
————————————————
版权声明：本文为CSDN博主「sodawaterer」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。 原文链接：https://blog.csdn.net/sodawaterer/article/details/72795468
 文件类型 文件类型的符号标识（ls -l命令下）
 - 普通文件 d 目录 b 块设备文件：保存大块数据的设备，比如硬盘。 s 套接字文件：网络数据连接过程中，通过套接字进行数据通信。 p 管道文件：用于解决多个程序同时存取同一个文件所造成的错误。 l 链接文件：快捷方式 c 字符设备文件：键盘、鼠标等。  </content>
    </entry>
    
     <entry>
        <title>[Tips]Raspberrypi相关</title>
        <url>https://litmingc.github.io/post/tips/raspberrypi%E7%9B%B8%E5%85%B3/</url>
        <categories>
          <category>学习笔记</category><category>Linux</category>
        </categories>
        <tags>
          <tag>挂载硬盘</tag><tag>berryconda</tag><tag>RaspberryPi</tag>
        </tags>
        <content type="html"> 常用初始化配置 新烧好系统之后，我常做的配置。列出来做个备忘。
 修改主机名 sudo vim /etc/hostname 修改密码 修改hosts 主要是添加127.0.0.1对前面修改的主机名的映射 sudo vim /etc/hosts v2ray配置 aria2配置* samba配置 docker配置* 挂载移动硬盘  挂载移动硬盘 NTFS  安装ntfs-3g sudo apt-get install ntfs-3g 查看设备 fdisk -l 准备挂载目录 sudo mkdir /mnt/dir 暂时挂载硬盘 ntfs-3g /dev/sda1 /mnt/dir 开机自动挂载
修改文件 /etc/fstab
添加如下内容： /dev/sda1 /mnt/dir ntfs utf8,uid=1000,gid=1000,umask=022 0 0  berryconda  环境：raspbian armv7l    问题：网络不佳，使用conda insatll无法下载openssl
解决：
 使用wget下载目标 conda insatll --use-local openssl本地文件安装    问题：conda insatll --use-local openssl本地文件安装出错
错误信息：CondaError: EOFError(&#39;Compressed file ended before the end-of-stream marker was reached&#39;,)
可能的原因：berryconda/pkgs/存在未正确下载的文件，安装时可能并没有用指定本地文件，而是用了缓存的文件？
解决： 删除berryconda/pkgs/目录下的相关文件，再次安装
  修改主机名后，sudo有异常提示  环境：Linux raspberrypi 4.19.88-OPENFANS&#43;20191229-v8 aarch64   问题：在cockpit中修改主机名，sudo功能正常，但有提示信息
信息：sudo: unable to resolve host raspberrypi: Name or service not known
解决：
修改/etc/hosts文件，将127.0.0.1映射到当前主机名。主机名所在文件为/etc/hostname。  安装Aria2  环境：Linux raspberrypi 4.19.88-OPENFANS&#43;20191229-v8 aarch64   下载对应的build包
【下载地址】 arm似乎没有，可以使用apt-get install aria2安装，但版本可能不是最新的。  samba安装 sudo apt-get install samba samba-common-bin配置文件
[public]comment = Public Storagepath = /home/piread only = no#任何人都具有了访问修改的权限#因为是公共文件夹，所以给了所有用户全部权限，可以自定义create mask = 0777#新创建文件的默认属性directory mask = 0777#新创建文件夹的默认属性guest ok = yes#默认的访问用户名为guestbrowseable = yes更多配置项1
 https://blog.csdn.net/qq_39626154/article/details/85335103 &amp;#x21a9;&amp;#xfe0e;
   </content>
    </entry>
    
     <entry>
        <title>[linux]Linux命令</title>
        <url>https://litmingc.github.io/post/linux/%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/</url>
        <categories>
          <category>学习笔记</category><category>Linux</category>
        </categories>
        <tags>
          <tag>tar</tag>
        </tags>
        <content type="html"> 【推荐网站】
“小”命令   uname
查看系统内核以及系统版本
参数：
 -a或&amp;ndash;all 显示全部的信息。 -m或&amp;ndash;machine 显示电脑类型。 -n或-nodename 显示在网络上的主机名称。 -r或&amp;ndash;release 显示操作系统的发行编号。 -s或&amp;ndash;sysname 显示操作系统名称。 -v 显示操作系统的版本。    getconf LONG_BIT
看看系统是32位还是64位
  uptime
查看负载信息
  free
显示当前系统中内存使用量信息
  打包与压缩 打包和压缩是不一样的 打包
利用tar命令，可以把一大堆的文件和目录全部打包成一个文件  压缩
利用gzip bzip2命令进行压缩 
命令tar .tar包并没有被压缩，tar只做打包功能，需要其他工具进行压缩。
解压命令格式：tar [选项] 压缩包
压缩命令格式：tar [选项] 压缩包 源文件或目录
示例
解压tar zxvf log.tar.gz
压缩tar zcvf log.tar.gz log2012.log 
选项(-)：
   短 长 备注     z gzip，ungzip 调用gzip执行压缩或解压缩。 .tar.gz文件使用。   j bzip2 调用bzip2执行压缩或解压缩。 .tar.bz2文件使用。   v verbose 显示处理过程   x extract，get 从打包文件中还原文件，解压用。   C  这个选项用在解压缩，在指定目录解压缩，-C 目录。   f file 指定目标文件。tar -f 文件路径或tar --file=文件路径。
所以，常用的解压组合中tar zxvf 文件路径中f必须放在最后，以获取参数。        c create 建立新的备份文件，新建打包。压缩用。    压缩/解压缩gzip 没咋单独用过。
执行压缩后，在原文件名后添加.gz后缀。 选项   -a或--ascii：使用ASCII文字模式；
-d或--decompress或--uncompress：解开压缩文件；
-f或--force：强行压缩文件。不理会文件名称或硬连接是否存在以及该文件是否为符号连接；
-h或--help：在线帮助；
-l或--list：列出压缩文件的相关信息；
-L或--license：显示版本与版权信息；
-n或--no-name：压缩文件时，不保存原来的文件名称及时间戳记；
-N或--name：压缩文件时，保存原来的文件名称及时间戳记；
-q或--quiet：不显示警告信息；
-r或--recursive：递归处理，将指定目录下的所有文件及子目录一并处理；
-S或&amp;lt;压缩字尾字符串&amp;gt;或&amp;mdash;-suffix&amp;lt;压缩字尾字符串&amp;gt;：更改压缩字尾字符串；
-t或--test：测试压缩文件是否正确无误；
-v或--verbose：显示指令执行过程；
-V或--version：显示版本信息；
-&amp;lt;压缩效率&amp;gt;：压缩效率是一个介于1~9的数值，预设值为“6”，指定愈大的数值，压缩效率就会愈高；
--best：此参数的效果和指定“-9”参数相同；
--fast：此参数的效果和指定“-1”参数相同。
 
压缩/解压缩bzip2 没咋单独用过。
执行压缩后，在原文件名后添加.bz2后缀。 选项   -c或--stdout：将压缩与解压缩的结果送到标准输出；
-d或--decompress：执行解压缩；
-f或--force：bzip2在压缩或解压缩时，若输出文件与现有文件同名，预设不会覆盖现有文件。若要覆盖。请使用此参数；
-h或--help：在线帮助；
-k或--keep：bzip2在压缩或解压缩后，会删除原始文件。若要保留原始文件，请使用此参数；
-s或--small：降低程序执行时内存的使用量；
-t或--test：测试.bz2压缩文件的完整性；
-v或--verbose：压缩或解压缩文件时，显示详细的信息；
-z或--compress：强制执行压缩；
-V或--version：显示版本信息；
--repetitive-best：若文件中有重复出现的资料时，可利用此参数提高压缩效果；
--repetitive-fast：若文件中有重复出现的资料时，可利用此参数加快执行效果。
 
备份系统与还原 就是，打包压缩整个系统。毕竟，linux一切都是以文件形式存在的。 但我没试过。 备份：
sudo tar cvpzf backup.tgz --exclude=/proc --exclude=/mnt --exclude=/sys --exclude=/backup.tgz / 这个命令，需要注意的就是排除一些不要备份的文件。
还原：
tar xvpfz backup.tgz -C /
此外，最好的选择还是备份工具。比如Rsync。
备份：
sudo rsync -Pa / /backup_20141216 --exclude=/media/* --exclude=/sys/* --exclude=/proc/* --exclude=/mnt/* --exclude=/tmp/*
还原：
sudo rsync -Pa /backup_20160511 /
</content>
    </entry>
    
     <entry>
        <title>[Tips]Hugo相关</title>
        <url>https://litmingc.github.io/post/tips/hugo%E7%9B%B8%E5%85%B3/</url>
        <categories>
          <category>Hugo</category>
        </categories>
        <tags>
          <tag>MathJax</tag>
        </tags>
        <content type="html"> 环境：
 hugo_extended_0.55.6_Windows-64bit    表达数学公式
  hugo主题：Next
  方案一： 先上参考：
MathJax Support
在Hugo中使用MathJax
修改公式显示的大小：
方法一：修改上述参考中的style。
方法二：使用如下代码：
&amp;lt;script type=&amp;#34;text/x-mathjax-config&amp;#34;&amp;gt;MathJax.Hub.Config({&amp;#34;HTML-CSS&amp;#34;: { scale: 175}});&amp;lt;/script&amp;gt;但是，MathJax在渲染的时候，速度有些慢。总要等很久。 又因为听说KaTeX挺快的（用了一下，还真的）。
参考上述改法，KaTeX的配置如下：
&amp;lt;link rel=&amp;#34;stylesheet&amp;#34; href=&amp;#34;https://cdn.jsdelivr.net/npm/katex@0.10.0-beta/dist/katex.min.css&amp;#34; integrity=&amp;#34;sha384-9tPv11A&#43;glH/on/wEu99NVwDPwkMQESOocs/ZGXPoIiLE8MU/qkqUcZ3zzL&#43;6DuH&amp;#34; crossorigin=&amp;#34;anonymous&amp;#34;&amp;gt;&amp;lt;script src=&amp;#34;https://cdn.jsdelivr.net/npm/katex@0.10.0-beta/dist/katex.min.js&amp;#34; integrity=&amp;#34;sha384-U8Vrjwb8fuHMt6ewaCy8uqeUXv4oitYACKdB0VziCerzt011iQ/0TqlSlv8MReCm&amp;#34; crossorigin=&amp;#34;anonymous&amp;#34;&amp;gt;&amp;lt;/script&amp;gt;&amp;lt;script src=&amp;#34;https://cdn.jsdelivr.net/npm/katex@0.10.0-beta/dist/contrib/auto-render.min.js&amp;#34; integrity=&amp;#34;sha384-aGfk5kvhIq5x1x5YdvCp4upKZYnA8ckafviDpmWEKp4afOZEqOli7gqSnh8I6enH&amp;#34; crossorigin=&amp;#34;anonymous&amp;#34;&amp;gt;&amp;lt;/script&amp;gt;&amp;lt;script&amp;gt;renderMathInElement(document.body,{delimiters: [{left: &amp;#34;$$&amp;#34;, right: &amp;#34;$$&amp;#34;, display: true},{left: &amp;#34;$&amp;#34;, right: &amp;#34;$&amp;#34;, display: false},],ignoredTags: [&amp;#39;script&amp;#39;, &amp;#39;noscript&amp;#39;, &amp;#39;style&amp;#39;, &amp;#39;textarea&amp;#39;, &amp;#39;pre&amp;#39;],});var all=document.getElementsByClassName(&amp;#39;katex&amp;#39;),i;for(i = 0; i &amp;lt; all.length; i &#43;= 1) {var tmp=all[i].parentNode;for(;tmp.nodeName==&amp;#39;SPAN&amp;#39;;tmp=tmp.parentNode);if(tmp.nodeName == &amp;#39;CODE&amp;#39;)tmp.className &#43;= &amp;#39; hasKatex&amp;#39;;}&amp;lt;/script&amp;gt;&amp;lt;style&amp;gt;code.hasKatex {font: inherit;font-size: 110%;background: inherit;border: inherit;color: #515151;}&amp;lt;/style&amp;gt;如同参考教程12所说的一样，公式中使用_等符号会和Markdown冲突造成渲染失败，上述解决方法是在公式外加一对``解决，同时调整公式父层code标签的样式（因为原先的code的样式背景是灰的）。
  方案二
上一种方案需要``把数学公式括起来，因而在使用vscode等编辑文档时非常不便于预览。幸运的是，在使用方案一的几天后，我又找到了方案二。
先上参考3
首先，和方案一一样引入KaTeX的代码块。因为不套用code块，也不需要调整code块的样式了，所以直接用官方默认的示例就行了：
&amp;lt;link rel=&amp;#34;stylesheet&amp;#34; href=&amp;#34;https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css&amp;#34; integrity=&amp;#34;sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/&#43;DiW/UqRcLbRjq&amp;#34; crossorigin=&amp;#34;anonymous&amp;#34;&amp;gt;&amp;lt;script defer src=&amp;#34;https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js&amp;#34; integrity=&amp;#34;sha384-y23I5Q6l&#43;B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd&#43;qj&#43;o24G5ZU2zJz&amp;#34; crossorigin=&amp;#34;anonymous&amp;#34;&amp;gt;&amp;lt;/script&amp;gt;&amp;lt;script defer src=&amp;#34;https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js&amp;#34; integrity=&amp;#34;sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI&amp;#34; crossorigin=&amp;#34;anonymous&amp;#34;&amp;gt;&amp;lt;/script&amp;gt;&amp;lt;script&amp;gt;document.addEventListener(&amp;#34;DOMContentLoaded&amp;#34;, function() {renderMathInElement(document.body, {// ...options... });});&amp;lt;/script&amp;gt;然后，安装pandoc。
最后，在MarkDown文件的front-matter部分加上markup: &amp;quot;pandoc&amp;quot;即可。
&amp;laquo;&amp;laquo;&amp;laquo;&amp;laquo;&amp;laquo;&amp;laquo;&amp;laquo;&amp;laquo;手工分割线&amp;laquo;&amp;laquo;&amp;laquo;&amp;laquo;&amp;laquo;&amp;laquo;&amp;laquo;&amp;laquo;
这里还有一些问题。其中，如果配置delimiters: 选项，一定要把符号配全，pandoc似乎会把美元符号自动替换成其他符号。
不用pandoc，用mmark也行，但官方表示mmark未来将会被移除。
    修改代码块的样式
主题：pure
修改css文件的&amp;lt;pre&amp;gt;标签的样式，样式参考
  使用tab键可能造成奇怪的渲染结局，应使用空格为宜
分割线上下最好留空行
   https://www.gohugo.org/doc/tutorials/mathjax/ &amp;ldquo;MathJax Support&amp;rdquo; &amp;#x21a9;&amp;#xfe0e;
 https://note.qidong.name/2018/03/hugo-mathjax/ &amp;#x21a9;&amp;#xfe0e;
 https://wrong.wang/flight-rules/20181130-%E4%BD%BF%E7%94%A8pandoc%E5%92%8Ckatex%E4%B8%BAhugo%E6%B7%BB%E5%8A%A0latex%E6%94%AF%E6%8C%81/ &amp;#x21a9;&amp;#xfe0e;
   </content>
    </entry>
    
     <entry>
        <title>[linux]进程管理</title>
        <url>https://litmingc.github.io/post/linux/%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/</url>
        <categories>
          <category>学习笔记</category><category>Linux</category>
        </categories>
        <tags>
          
        </tags>
        <content type="html"> 相关字段的含义 表太长，我折叠了     表头 含义     USER 进程由哪个用户产生   PID 进程id   PPID 父进程id   %CPU 或者 C 占用cpu   %MEM 占用物理内存   VSC 占用虚拟内存的大小，单位KB   RSS 占用物理内存的大小，单位KB   PRI 进程优先级，数值越小，优先级越高。PRI &#43;= nice   NI 即nice，用户可修改。   WCHAN 是否在运行，-表示在运行   TTY tty1 ~ tty7 代表本地控制台终端，tty7 是图型终端。
pts/0 ~ 255 代表虚拟终端，一般是远程连接的终端，第一个远程连接占用 pts/0，第二个远程连接占用 pts/1，依次増长。   STAT 或者 S 进程状态。常见的状态有以下几种： 1. -D：不可被唤醒的睡眠状态，通常用于 I/O 情况。 2. -R：该进程正在运行。 3. -S：该进程处于睡眠状态，可被唤醒。 4. -T：停止状态，可能是在后台暂停或进程处于除错状态。 5. -W：内存交互状态（从 2.6 内核开始无效）。 6. -X：死掉的进程（应该不会出现）。 7. -Z：僵尸进程。进程已经中止，但是部分程序还在内存当中。 8. -&amp;lt;：高优先级（以下状态在 BSD 格式中出现）。 9. -N：低优先级。 10. -L：被锁入内存。 11. -s：包含子进程。 12. -l：多线程（小写 L）。
13. -&#43;：位于后台。   TIME 占用cpu的时间   COMMAND 命令   FD 文件描述符   TYPE REG：文件；DIR：目录；CHR：字符；BLK：块设备；UNIX：unix套接字；FIFO：先进先出队列；IPv4等：IP套接字   DEVICE 指定磁盘名称   NODE 索引节点（文件在磁盘中的标识）     进程后台执行   在命令后使用 &amp;amp; 符号
后台运行
find / -name abc.jpg &amp;amp;常见搭配：输出重定向，使用&amp;gt;符号，如下
# 命令 &amp;gt; 目标文件 &amp;amp;# 将命令在后台运行，并将输出导出到目标文件cat a.txt &amp;gt; 目标文件 &amp;amp;  nohup命令
进程脱离终端执行：当前终端退出时，进程不被打断
 no hang up，即不挂断，但不是在后台运行，搭配&amp;amp;使用。  nohup find / -name abc.jpg &amp;amp;  jobs命令
查看当前终端的后台工作
jobs [options]options:
 -l：列出进程PID号 -n：只显示状态改变的进程 -p：只显示PID -r：筛选running状态的进程 -s：筛选stoppde状态的进程  输出
工作号 &#43;- status commend
&#43;表示新增工作
  fg命令
将后台命令恢复到前台
fg [[%]工作号]工作号为jobs输出[]中的数字 默认恢复最新命令，即带&#43;的工作
  bg命令
将后台暂停的工作启动
bg [[%]工作号]  查看进程信息——ps命令    命令选项 含义     a 显示一个终端的所有进程，除会话引线外   u 显示进程的归属用户及内存的使用情况   x 显示没有控制终端的进程   -l 长格式显示更加详细的信息   -e 显示所有进程        实时监听进程信息——top命令   交互操作
 ？或者 h ：帮助 p ：按cpu占用排序 m ：按照内存占用排序 t ：按TIME排序 k ：终止（kill）进程，指定PID，Esc退出 r ：重新设置nice值，指定PID，Esc退出 q ：退出top    命令选项
 -d 秒数：top命令几秒更新一次。默认3秒 -b：使用批处理模式。据说，用于将信息保存输出到文件。 -n 次数：指定top命令的执行次数。 -p 进程PID：查看指定进程。 -s：安全模式。避免在交互过程中出错。 -u 用户名：只监听某个用户的进程。    注：cache 、 buffer的区别部分显示注解：
 cache：读取硬盘的数据缓存 buffer：写入硬盘的数据缓存  查看进程树——pstree命令 pstree [option] [PID or username]
option:
 -a：显示启动每个进程对应的完整指令 -c：不使用精简法显示进程信息 -n：根据PID排序 -p：显示PID -u：显示用户名  查看文件调用——lsof命令 lsof [options] [filename]
option：
 -c 字符串：筛选以此字符串开头的命令 &#43;d 目录：筛选目录 -u 用户名：筛选用户 -p PID：筛选PID  调整进程优先级 进程优先级涉及到的参数问题 PRI:Priority，越小优先级越高 NI:nice  PRI(new) = PRI(old) &#43; nice ，
其中：
 NI $\epsilon$ [-20,19] 普通用户只能调整自己的进程，只能调高NI值，且调整范围为[0,19] ；root用户不受限    nice命令
nice [-n NI值] commend
  renice命令
renice [NI值] PID 与nice不同，可以在命令运行中修改NI值
  终止进程   kill命令
kill [signal] PIDkill [-信号编号] PID   信号编号 信号名 含义     1 HUP    9 KILL 杀死进程   15 TERM 正常结束进程，kill默认信号      killall命令
killall [options] [signal] 进程名options:
 -i:交互式，询问是否杀死进程 -l:忽略进程名的大小写    pkill命令
pkill [signal] [-t tty] [进程名]重要功能 -t：指定终端
# 例如：# 强制杀死从pts/1虚拟终端登录的进程pkill -9 -t pts/1  </content>
    </entry>
    
     <entry>
        <title>QLineEdit</title>
        <url>https://litmingc.github.io/post/python/%E7%AC%94%E8%AE%B0qlineedit/</url>
        <categories>
          <category>学习笔记</category><category>python</category>
        </categories>
        <tags>
          <tag>PyQt5</tag>
        </tags>
        <content type="html">   环境：
 python 3.7 PyQt5 5.13.0    QLineEdit   控制输入   正则表达式
Validator = QRegExpValidator(self) # 校验器 # 为校验器配置QRegExp(), 参数r&amp;#34;[0-9]&amp;#34;为正则表达式  Validator.setRegExp(QRegExp(r&amp;#34;[0-9]&amp;#34;))c = QLineEdit()c.setValidator(Validator)  掩码
掩码对比正则表达式：掩码使用占位符；正则表达式则没有占位。所以，在没有输入的情况下，掩码的光标可以在占下的位置间移动，而且输入方式相当于更新，而不是插入。
c = QLineEdit()c.setInputMask(&amp;#39;0&amp;#39;) # 设置掩码：一位 0-9 的字符 c.setInputMask(&amp;#39;000&amp;#39;) # 设置掩码：三位 0-9 的字符 掩码占位符表
参考网上搜到的表格，但在应用时，原表中“必须输入”以及“不是必需的”的差异未有体现，下表为个人试验得出的意见。
【注】试验时，有效的代码部分仅为上述代码更换掩码而已。
   占位字符 含义     A，a 只允许输入【A~Z, a~z】以及汉字   N，n 只允许输入【A~Z, a~z, 0~9】以及汉字   X，x 允许输入各种字符，标点   9，0 只允许输入0-9的数字   D，d 只允许输入1-9的数字   # 只允许输入1-9的数字、加号&#43;、减号-   H，h 只允许输入A~F、 a~f、0-9，即十六进制数字   B，b 只允许输入0、1，即二进制数字   &amp;gt; 搭配上述字符，将字符自动变大写，可输入汉字   &amp;lt; 搭配上述字符，将字符自动变小写，可输入汉字   ! 搭配上述字符，从！的位置开始，关闭 &amp;gt; 、&amp;lt;的大小写转换效果。
例如：&#39;&amp;lt;aaa!aaa&amp;rsquo;，前三个字符会转换为小写，后三个字符不会被转换成小写      </content>
    </entry>
    
</search>